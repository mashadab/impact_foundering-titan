
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>impactorTempMeltFunc</title><meta name="generator" content="MATLAB 9.10"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2023-05-30"><meta name="DC.source" content="impactorTempMeltFunc.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><pre class="codeinput"><span class="keyword">function</span> impactorTempMeltFunc(fn,eta_0,E_a)
<span class="comment">    %{
</span><span class="comment">    Function to evolve impact melt chambers on Europa. Simulations end
</span><span class="comment">    when there is a negligible amount of melt left from the impact. The
</span><span class="comment">    ouputs are saved at the breakpoint in line 294. This model is meant for
</span><span class="comment">    short term simulations, on the order of the sinking of impact melts.
</span><span class="comment">
</span><span class="comment">    Variables:
</span><span class="comment">        fn (string): is the directory to find the initial conditions (the
</span><span class="comment">        outputs from the impact simulation)
</span><span class="comment">        eta_0 (int): basal viscosity of ice in Pa s, 1e14 is a common value
</span><span class="comment">        E_a (int): visocisty activation energy in Arrhenihus relationship
</span><span class="comment">        given in J/mol, 50e3 is a common value
</span><span class="comment">
</span><span class="comment">    Author: Evan Carnahan, evan.carnahan@utexas.edu, 11/20/2022
</span><span class="comment">    %}publish('script.m','pdf')
</span><span class="comment">
</span><span class="comment">    set(groot,'defaulttextinterpreter','latex')
</span><span class="comment">    set(groot,'defaultAxesTickLabelInterpreter','latex')
</span><span class="comment">    set(groot,'defaultLegendInterpreter','latex')
</span><span class="comment">    warning off; % matrix is close to singular due to viscosity contrast
</span><span class="comment">    %% Load initial condition to be evolved
</span><span class="comment">    % make ice shell thickness based on impact code passed
</span><span class="comment">    if any([all(fn == '03321') all(fn == '03800') all(fn == '04304')])
</span><span class="comment">        d = 10*1e3; % m
</span><span class="comment">    elseif any([all(fn == '03314') all(fn == '03402') all(fn == '03400')])
</span><span class="comment">        d = 20*1e3; % m
</span><span class="comment">    elseif any([all(fn == '03313') all(fn == '03701')])
</span><span class="comment">        d = 30*1e3; % m
</span><span class="comment">    elseif all(fn == '03330')
</span><span class="comment">        d = 40*1e3; % m
</span><span class="comment">    end
</span><span class="comment">
</span><span class="comment">    % threshold of intial fluid left in ice shell to stop simulation at
</span><span class="comment">    termFrac = 0.005;
</span><span class="comment">
</span><span class="comment">    % load simulations from initial conditions folder
</span><span class="comment">    fp = '../initial_conditions/ic';
</span><span class="comment">    load([fp fn '_100.mat'],'T','phi');
</span><span class="comment">
</span><span class="comment">    %% Set physical parameters and make dimensionless scales
</span><span class="comment">    % physical parameters for ice
</span><span class="comment">    T_t = 100; % surface temperature
</span><span class="comment">    a = 185; % ice specific heat parameter
</span><span class="comment">    b = 7.037; % ice specific heat parameter
</span><span class="comment">    T_b = 273; % melting temperature, K
</span><span class="comment">    rho_i = 920; % ice density at melting temperature, kg/m^3
</span><span class="comment">    grav = 1.315; % Europa gravity, m/s^2
</span><span class="comment">    DT = T_b - T_t; % difference in temperature
</span><span class="comment">    alpha = 1.6e-4; % thermal expansion coefficient, 1/K
</span><span class="comment">    R = 8.314; % universal gas constant, J K^-1 mol^-1
</span><span class="comment">    Apar = E_a/R/T_b; % viscosity exponenet
</span><span class="comment">
</span><span class="comment">    % physical properties of water
</span><span class="comment">    latHeat = 334e3; % latent heat of fusion, J/kg
</span><span class="comment">    rho_w = 1e3; % density of water, kg/m^3
</span><span class="comment">    c_pw = 4.186e3; % specific ehat of water, J/kg
</span><span class="comment">    kappa_w = 0.56; %thermal diffusivity of water, W/(m K)
</span><span class="comment">    porViscPar = 45;
</span><span class="comment">
</span><span class="comment">    % temperature and melt fraction dependent viscosity, Pa s
</span><span class="comment">    barrViscPhi = @(nonT,phi) max(exp(Apar*(T_b./(DT.*nonT+T_t)-1)).*exp(-porViscPar*phi),1e-2);
</span><span class="comment">    c_fun = @(nonT) a+b*(DT*nonT+T_t); %J/(kg K)
</span><span class="comment">    kappa_b = 3.3; %thermal conductivity of ice, set to be consistent with Cox and Bauer, 2015
</span><span class="comment">    D_T = kappa_b/(rho_i *c_fun(1)); % thermal diffusicvity of ice, m^2/s
</span><span class="comment">    c_pi = c_fun(1); %constant specific heat, J/(kg K)
</span><span class="comment">
</span><span class="comment">
</span><span class="comment">    % thershold for melting: dimensionless boundary between partial and
</span><span class="comment">    % fully melted regions
</span><span class="comment">    mixZone = (rho_w*latHeat)/(rho_i*c_pi*DT);
</span><span class="comment">
</span><span class="comment">    phi_fun = @(nonH) nonH * (rho_i*c_pi*DT)/(rho_w*latHeat);
</span><span class="comment">    TWater_fun = @(nonH) nonH * (rho_i*c_pi)/(rho_w*c_pw) - latHeat/(DT*c_pw) + 1;
</span><span class="comment">    compBouy_fun = @(phi)  phi*rho_i*(rho_w/rho_i-1)*(grav*d^3/(eta_0*D_T));
</span><span class="comment">
</span><span class="comment">    % conversion in dimensionless units with constant specific heat
</span><span class="comment">    nonH_fun = @(nonT) nonT - 1;
</span><span class="comment">    nonT_fun = @(nonH) nonH + 1;
</span><span class="comment">    % condictivity is weighted average of mixture components
</span><span class="comment">    porKappaPrime_fun = @(phi,nonT) (phi*kappa_w + (1-phi).*kappa_b)/kappa_b;
</span><span class="comment">    porNonH_fun = @(phi,nonT) (1-phi).*(nonH_fun(nonT)) + ...
</span><span class="comment">        (phi*rho_w)./(rho_i*c_pi*DT).*(latHeat+c_pw*DT*(nonT-1));
</span><span class="comment">
</span><span class="comment">    % characteristic scales for general convection
</span><span class="comment">    t_c = d^2/D_T; % dimensionless time, s
</span><span class="comment">    Ra = rho_i*grav*alpha*d^3*DT/(eta_0*D_T); % basal Rayleigh number
</span><span class="comment">
</span><span class="comment">    % non-dimensionalize tmeprature
</span><span class="comment">    T = (T - T_t)/DT;
</span><span class="comment">
</span><span class="comment">    % thermal condutvity in convective ocean, set to maintain vertical
</span><span class="comment">    % geotherm in ocean
</span><span class="comment">    kappa_c = 100;
</span><span class="comment">
</span><span class="comment">    %% build cylindirical grid for numerical solution
</span><span class="comment">    % build grid
</span><span class="comment">    grRes = 100; % grid resolution
</span><span class="comment">    ocTh = grRes/5; % make ocean below the ice shell
</span><span class="comment">    Gridp.xmin = 0; Gridp.xmax = 2; Gridp.Nx = grRes;
</span><span class="comment">    Gridp.ymin = -ocTh/grRes; Gridp.ymax = 1; Gridp.Ny = grRes+ocTh;
</span><span class="comment">    Gridp.geom = 'cylindrical_rz';
</span><span class="comment">    Grid = build_stokes_grid_cyl(Gridp);
</span><span class="comment">
</span><span class="comment">    % convert inital condition to grid
</span><span class="comment">    TGr = reshape(T,grRes,Grid.p.Nx);
</span><span class="comment">    phiGr = reshape(phi,grRes,Grid.p.Nx);
</span><span class="comment">    % get initial melt volumes
</span><span class="comment">    phiOrig = sum(sum(phiGr(10:end,:),1).*Grid.p.V(Grid.p.dof_ymin)' * d^3);
</span><span class="comment">
</span><span class="comment">    % build ocean layer
</span><span class="comment">    TOc = ones(ocTh,Grid.p.Nx);
</span><span class="comment">    phiOc = ones(ocTh,Grid.p.Nx);
</span><span class="comment">
</span><span class="comment">    % combine ice shell and ocean
</span><span class="comment">    TGr = [TOc; TGr];
</span><span class="comment">    phiGr = [phiOc; phiGr];
</span><span class="comment">    T = TGr(:);
</span><span class="comment">    phi = phiGr(:);
</span><span class="comment">    H = porNonH_fun(phi,T);
</span><span class="comment">
</span><span class="comment">    %% build operators
</span><span class="comment">    Zp = zeros(Grid.p.N);
</span><span class="comment">    Ip = speye(Grid.p.N);
</span><span class="comment">    [D,Edot,Dp,Gp,I,Gyy]=build_stokes_ops_cyl(Grid);
</span><span class="comment">    linInds = find(Gyy &gt; 0);
</span><span class="comment">    [row,~] = ind2sub(size(Gyy),linInds);
</span><span class="comment">    [X,Y] = meshgrid(Grid.p.xc,Grid.p.yc);
</span><span class="comment">
</span><span class="comment">    %% Build boundary conditions for temperature and flow equation
</span><span class="comment">    % Fix temperature at top of ice shell with Dirchlet BC
</span><span class="comment">    T0 = 0;
</span><span class="comment">    H0 = nonH_fun(T0);
</span><span class="comment">    Param = struct('H',{},'g',{},'dof_dir',{});
</span><span class="comment">    Param(1).H = struct('dof_dir',{},'dof_f_dir',{},'g',{},'dof_neu',{},'dof_f_neu',{},'qb',{},'dof_out',{});
</span><span class="comment">
</span><span class="comment">    % fix bottom heat flux, Neumann BC, to maintain linear geotherm in ice shell
</span><span class="comment">    qPrime = 1;
</span><span class="comment">    Param.H(1).dof_dir = [Grid.p.dof_ymax];
</span><span class="comment">    Param.H(1).dof_f_dir = [Grid.p.dof_f_ymax];
</span><span class="comment">    Param.H(1).g = [H0*ones(length(Grid.p.dof_ymax),1)];
</span><span class="comment">
</span><span class="comment">    Param.H(1).dof_neu = [Grid.p.dof_xmin;Grid.p.dof_xmax;Grid.p.dof_ymin];
</span><span class="comment">    Param.H(1).dof_f_neu = [Grid.p.dof_f_xmin;Grid.p.dof_f_xmax;Grid.p.dof_f_ymin];
</span><span class="comment">    Param.H(1).qb = [0*Grid.p.dof_f_xmin;0*Grid.p.dof_f_xmax;qPrime*ones(size(Grid.p.dof_f_ymin))];
</span><span class="comment">    [BH,NH,fn_H] = build_bnd(Param.H,Grid.p,Ip);
</span><span class="comment">    Param.H(1).dof_out = [Grid.p.dof_ymin];
</span><span class="comment">
</span><span class="comment">
</span><span class="comment">    % Free slip boundary condition for Stokes equation
</span><span class="comment">    Param(1).dof_dir =  [...
</span><span class="comment">                      Grid.x.dof_xmax;...           %set x_max x-vel
</span><span class="comment">                      Grid.x.dof_xmin;...           %set x_min x-vel
</span><span class="comment">                      Grid.x.N+Grid.y.dof_ymin;...  %set y_min y-vel
</span><span class="comment">                      Grid.x.N+Grid.y.dof_ymax;...  %set y_max y-vel
</span><span class="comment">                      Grid.p.Nf+1];                 %set pressure
</span><span class="comment">    Param(1).g = 0*Param.dof_dir;
</span><span class="comment">    Param.g(end) = 0;
</span><span class="comment">    B = I([Param.dof_dir],:);
</span><span class="comment">    N = I;
</span><span class="comment">    N(:,[Param.dof_dir]) = [];
</span><span class="comment">    fs_T = nan(size(T));
</span><span class="comment">
</span><span class="comment">
</span><span class="comment">    % create aarrays for time evolution storage
</span><span class="comment">    it = 1e9;
</span><span class="comment">    netMelt = [];
</span><span class="comment">    phiDrain1 = 0;
</span><span class="comment">    phiDrain2 = 0;
</span><span class="comment">    tTot = 0;
</span><span class="comment">    tVec = [];
</span><span class="comment">    phiDrain1Vec = [];
</span><span class="comment">    phiDrain2Vec = [];
</span><span class="comment">    phiFracRem = [];
</span><span class="comment">
</span><span class="comment">    %% temporal evolution
</span><span class="comment">    for i = 1:it
</span><span class="comment">
</span><span class="comment">        % calculate porosity from enthalpy
</span><span class="comment">        [T,phi] = enthMelt(H,mixZone,nonT_fun,phi_fun,TWater_fun);
</span><span class="comment">        H = porNonH_fun(phi,T);
</span><span class="comment">
</span><span class="comment">        %% Bouyancy force as the body force to Stokes flow
</span><span class="comment">        %temp bouyancy
</span><span class="comment">        Tplot= reshape(T,Grid.p.Ny,Grid.p.Nx);
</span><span class="comment">        Tdiag = comp_mean(Tplot,1,1,Grid.p);
</span><span class="comment">        Tvec = diag(Tdiag);
</span><span class="comment">        Ty = Tvec(Grid.p.Nfx+1:Grid.p.Nf);
</span><span class="comment">        fs_T(Ty&gt;1) = -Ra*1;
</span><span class="comment">        fs_T(Ty&lt;=1) = -Ra*Ty(Ty&lt;=1);
</span><span class="comment">
</span><span class="comment">        %compositional bouyancy
</span><span class="comment">        phiPlot= reshape(phi,Grid.p.Ny,Grid.p.Nx);
</span><span class="comment">        phiDiag = diag(comp_mean(phiPlot,1,1,Grid.p));
</span><span class="comment">        phiY = phiDiag(Grid.p.Nfx+1:Grid.p.Nf);
</span><span class="comment">        fs_por = compBouy_fun(phiY);
</span><span class="comment">
</span><span class="comment">        % higher porosity acts against Ra bouyancy force
</span><span class="comment">        fsVec = fs_T + fs_por;
</span><span class="comment">        fs = [zeros(Grid.p.Nfx,1); fsVec; zeros(Grid.p.N,1)];
</span><span class="comment">
</span><span class="comment">        %Gxx variable viscosity matrix
</span><span class="comment">        nxxVec = zeros(Grid.x.Nfx,1);
</span><span class="comment">        nxxVec(Grid.x.Ny+Grid.p.dof) = Tplot;
</span><span class="comment">
</span><span class="comment">        %Gyy variable viscosity matrix
</span><span class="comment">        nyyVec = zeros(Grid.y.Nfy,1);
</span><span class="comment">        nyyVec(row) = Tplot;
</span><span class="comment">        ncVec = comp_mean_corners(Tplot,-1,Grid.p);
</span><span class="comment">        tempVec = [nxxVec;nyyVec;ncVec];
</span><span class="comment">
</span><span class="comment">        %% Porosity and temperature dependent viscosity
</span><span class="comment">        % porosity dependent viscosity
</span><span class="comment">        phiPlot = reshape(phi,Grid.p.Ny,Grid.p.Nx);
</span><span class="comment">        nxxVecPhi = zeros(Grid.x.Nfx,1);
</span><span class="comment">        nxxVecPhi(Grid.x.Ny+Grid.p.dof) = phiPlot;
</span><span class="comment">
</span><span class="comment">        %Gyy variable viscosity matrix
</span><span class="comment">        nyyVecPhi = zeros(Grid.y.Nfy,1);
</span><span class="comment">        nyyVecPhi(row) = phiPlot;
</span><span class="comment">
</span><span class="comment">        ncVecPhi = comp_mean_corners(phiPlot,-1,Grid.p);
</span><span class="comment">        phiVec = [nxxVecPhi;nyyVecPhi;ncVecPhi];
</span><span class="comment">
</span><span class="comment">        % merge temperature and melt fraction viscosities
</span><span class="comment">        viscVec = barrViscPhase(tempVec,phiVec,barrViscPhi);
</span><span class="comment">        viscVec(isnan(viscVec)) = 0;
</span><span class="comment">        viscMat = spdiags(viscVec,0,length(viscVec),length(viscVec));
</span><span class="comment">
</span><span class="comment">        %% Stokes Flow calcualtion
</span><span class="comment">        % make linear operators
</span><span class="comment">        tau = D*2*viscMat*Edot;
</span><span class="comment">        L = [tau,Gp;
</span><span class="comment">            Dp,Zp];
</span><span class="comment">        % solve for flow velocities
</span><span class="comment">        u = solve_lbvp(L,fs,B,Param.g,N);
</span><span class="comment">        vx = u(1:Grid.p.Nfx);
</span><span class="comment">        vy = u(Grid.p.Nfx+1:(Grid.p.Nfx+Grid.p.Nfy));
</span><span class="comment">        vm = [vx;vy];
</span><span class="comment">        vmax= max(abs(vm));
</span><span class="comment">        % Adaptive time stepping based on CFL condition
</span><span class="comment">        dt = min([0.5*Grid.p.dx^2/kappa_c, Grid.p.dx/vmax,0.5*Grid.p.dy^2/kappa_c, Grid.p.dy/vmax])*0.8;
</span><span class="comment">        p  = u((Grid.p.Nfx+Grid.p.Nfy+1):end);
</span><span class="comment">
</span><span class="comment">        %% non-linear thermal conducitivity matricies
</span><span class="comment">        kappaPrime = porKappaPrime_fun(phi,T);
</span><span class="comment">        % select near bouundary ocean cells
</span><span class="comment">        ocLog = Y(:) &lt; 2/grRes &amp; phi &gt; 0.5;
</span><span class="comment">        kappaPrime(ocLog) = kappa_c;
</span><span class="comment">        kappaPrimePlot = reshape(kappaPrime,Grid.p.Ny,Grid.p.Nx);
</span><span class="comment">        kappaFace = comp_mean(kappaPrimePlot,1,1,Grid.p);
</span><span class="comment">
</span><span class="comment">        %% Advection of enthalpy, diffusion of temperature
</span><span class="comment">        AH = build_adv_op(vm,H,dt,Gp,Grid.p,Param.H,'mc');
</span><span class="comment">        L_T_I = Ip;
</span><span class="comment">        L_T_E_T = - dt*(-Dp*kappaFace*Gp);
</span><span class="comment">        L_T_E_H = Ip - dt*(Dp*AH);
</span><span class="comment">        RHS_T = L_T_E_H*H + L_T_E_T*T + (fn_H)*dt;
</span><span class="comment">        H = solve_lbvp(L_T_I,RHS_T,BH,Param.H.g,NH);
</span><span class="comment">
</span><span class="comment">        %% calculate net melt and melt transported to "ocean"
</span><span class="comment">        % make two planes to measure the melt transported through
</span><span class="comment">        % plane 1
</span><span class="comment">        abInd = 5;
</span><span class="comment">        phiGr = reshape(phi,Grid.p.Ny,Grid.p.Nx);
</span><span class="comment">        bdPhi = mean(phiGr(ocTh+abInd:ocTh+abInd+1,:),1).*Grid.p.V(Grid.p.dof_ymin)';
</span><span class="comment">        vyGr = reshape(vy,Grid.y.Ny,Grid.y.Nx);
</span><span class="comment">        bdVy = vyGr(ocTh+abInd+1,:);
</span><span class="comment">        meltTrans = bdPhi .* bdVy / Grid.p.dy * dt * d^3;
</span><span class="comment">        phiDrain2 = phiDrain2 - sum(meltTrans(bdVy &lt; 0)); % m^3
</span><span class="comment">        phiDrain2Vec = [phiDrain2Vec phiDrain2];
</span><span class="comment">
</span><span class="comment">        % plane 2
</span><span class="comment">        phiGr = reshape(phi,Grid.p.Ny,Grid.p.Nx);
</span><span class="comment">        bdPhi = mean(phiGr(ocTh+(abInd-1):ocTh+(abInd-1)+1,:),1).*Grid.p.V(Grid.p.dof_ymin)';
</span><span class="comment">        vyGr = reshape(vy,Grid.y.Ny,Grid.y.Nx);
</span><span class="comment">        bdVy = vyGr(ocTh+(abInd-1)+1,:);
</span><span class="comment">        meltTrans = bdPhi .* bdVy / Grid.p.dy * dt * d^3;
</span><span class="comment">        phiDrain1 = phiDrain1 - sum(meltTrans(bdVy &lt; 0)); % m^3
</span><span class="comment">        phiDrain1Vec = [phiDrain1Vec phiDrain1];
</span><span class="comment">
</span><span class="comment">        % total melt left
</span><span class="comment">        netMelt = [netMelt sum(phi .* Grid.p.V * d^3)];
</span><span class="comment">        % select near bouundary ocean cells
</span><span class="comment">        % time stepping
</span><span class="comment">        tTot = tTot + dt*t_c/(3.154e7); %Yrs
</span><span class="comment">        tVec = [tVec tTot];
</span><span class="comment">
</span><span class="comment">        % calculate remaining phi above near ocean, bottom 20% of ice shell
</span><span class="comment">        phiRem = sum(sum(phiGr(ocTh+grRes/5:end,:),1).*Grid.p.V(Grid.p.dof_ymin)' * d^3);
</span><span class="comment">        phiFracRem = [phiFracRem phiRem/phiOrig];
</span><span class="comment">
</span><span class="comment">        % condition for ending simulation
</span><span class="comment">        if phiFracRem(end) &lt; termFrac || (i &gt; 1000 &amp;&amp; phiFracRem(end) &gt; phiFracRem(end-1))
</span><span class="comment">            % save point
</span><span class="comment">            save(['impact_' fn '_eta0_' num2str(log10(eta_0)) '_Ea_' num2str(E_a/1e3) '_output.mat'],...
</span><span class="comment">                'Tplot','phi','Grid','phiDrain1Vec','phiDrain2Vec','phiOrig','tVec',...
</span><span class="comment">                'phiFracRem','T','phi','tVec','phiDrain1Vec','phiDrain2Vec','phiOrig')
</span><span class="comment">            break
</span><span class="comment">        end
</span><span class="comment">
</span><span class="comment">
</span><span class="comment">        %% PLOTTING
</span><span class="comment">         if mod(i,10) == 0
</span><span class="comment">             i
</span><span class="comment">
</span><span class="comment">            figure(4);
</span><span class="comment">            [PSI,psi_min,psi_max] = comp_streamfun(vm,Grid.p);
</span><span class="comment">            set(gcf, 'Position', [50 50 1500 600])
</span><span class="comment">            subplot(3,3,1)
</span><span class="comment">            cla;
</span><span class="comment">            hold on
</span><span class="comment">            axis equal
</span><span class="comment">            contourf(X*d/1e3,Y*d/1e3-Grid.p.dy,Tplot*DT+T_t,40,'linestyle','none'),view(2),hold on
</span><span class="comment">            c = colorbar('NorthOutside');
</span><span class="comment">            caxis([min(Tplot(:)) max(Tplot(:))]*DT+T_t);
</span><span class="comment">            cStrVal = linspace(min(PSI(:)),max(PSI(:)),10);
</span><span class="comment">            contour(Grid.p.xf*d/1e3,Grid.p.yf*d/1e3,PSI,'k','LevelList',cStrVal);
</span><span class="comment">            c.Label.String = 'Temperature, K';
</span><span class="comment">            xlabel('x-dir, km')
</span><span class="comment">            ylabel('z-dir, km')
</span><span class="comment">
</span><span class="comment">            subplot(3,3,2)
</span><span class="comment">            cla;
</span><span class="comment">            axis equal
</span><span class="comment">            hold on
</span><span class="comment">            contourf(X,Y,reshape(phi,Grid.p.Ny,Grid.p.Nx),40,'linestyle','none'),view(2),hold on
</span><span class="comment">            c = colorbar('NorthOutside');
</span><span class="comment">            contour(X,Y,reshape(phi,Grid.p.Ny,Grid.p.Nx),'r','LevelList',5e-2)
</span><span class="comment">            xlabel('x-dir, 1')
</span><span class="comment">            ylabel('z-dir, 1')
</span><span class="comment">            c.Label.String = 'Melt fraction, 1';
</span><span class="comment">
</span><span class="comment">
</span><span class="comment">            subplot(3,3,3)
</span><span class="comment">            cla;
</span><span class="comment">            plot(mean(reshape(phi,Grid.p.Ny,Grid.p.Nx),2),Grid.p.yc)
</span><span class="comment">            ylabel('z-dir, 1');
</span><span class="comment">            xlabel('Average melt fraction');
</span><span class="comment">
</span><span class="comment">            subplot(3,3,4)
</span><span class="comment">            cla;
</span><span class="comment">            plot(mean(reshape(T,Grid.p.Ny,Grid.p.Nx),2),Grid.p.yc)
</span><span class="comment">            xlabel('Avg. temp');
</span><span class="comment">            ylabel('z-dir, 1');
</span><span class="comment">
</span><span class="comment">
</span><span class="comment">            subplot(3,3,5)
</span><span class="comment">            cla;
</span><span class="comment">            hold on
</span><span class="comment">            plot(phiFracRem);
</span><span class="comment">            ylabel('Total melt remaining, \%');
</span><span class="comment">            xlabel('Time, yrs')
</span><span class="comment">
</span><span class="comment">            subplot(3,3,6)
</span><span class="comment">            cla;
</span><span class="comment">            hold on
</span><span class="comment">            axis equal
</span><span class="comment">            contourf(X,Y,reshape(kappaPrimePlot,Grid.p.Ny,Grid.p.Nx),40,'linestyle','none'),view(2),hold on
</span><span class="comment">            c = colorbar('NorthOutside');
</span><span class="comment">            xlabel('x-dir, m')
</span><span class="comment">            ylabel('z-dir, m')
</span><span class="comment">            c.Label.Interpreter = 'latex';
</span><span class="comment">            c.TickLabelInterpreter = 'latex';
</span><span class="comment">            c.Label.String = 'Non-dim thermal conductivity';
</span><span class="comment">
</span><span class="comment">            [Xc,Yf] = meshgrid(Grid.p.xc,Grid.p.yf);
</span><span class="comment">            subplot(3,3,7)
</span><span class="comment">            cla;
</span><span class="comment">            plot(tVec,phiDrain1Vec);
</span><span class="comment">            hold on
</span><span class="comment">            plot(tVec,phiDrain2Vec);
</span><span class="comment">            legend('intefrace','1 above interface','Location','NorthWest');
</span><span class="comment">            ylabel('Melt drained, m$^3$');
</span><span class="comment">            xlabel('Time, yrs')
</span><span class="comment">
</span><span class="comment">            subplot(3,3,8)
</span><span class="comment">            cla;
</span><span class="comment">            plot(tVec,phiDrain1Vec/phiOrig*100);
</span><span class="comment">            hold on
</span><span class="comment">            plot(tVec,phiDrain2Vec/phiOrig*100);
</span><span class="comment">            legend('interface','1 above interface','Location','NorthWest');
</span><span class="comment">            ylabel('Percentage of melt drained, \%');
</span><span class="comment">            xlabel('Time, yrs')
</span><span class="comment">
</span><span class="comment">            subplot(3,3,9)
</span><span class="comment">            cla;
</span><span class="comment">            axis equal
</span><span class="comment">            contourf(Xc,Yf,reshape(-fsVec,Grid.p.Ny+1,Grid.p.Nx),40,'linestyle','none'),view(2),hold on
</span><span class="comment">            c = colorbar('NorthOutside');
</span><span class="comment">            c.Label.Interpreter = 'latex';
</span><span class="comment">            c.TickLabelInterpreter = 'latex';
</span><span class="comment">            c.Label.String = 'Total Bouyancy, 1';
</span><span class="comment">            xlabel('x-dir, 1')
</span><span class="comment">            ylabel('z-dir, 1')
</span><span class="comment">
</span><span class="comment">         end
</span><span class="comment">    end
</span><span class="comment">end</span>
</pre><pre class="codeoutput error">Error using dbstatus
Error: File: /Users/afzal-admin/Documents/Research/impact_foundering-titan/model_and_dependencies/impactorTempMeltFunc.m Line: 399 Column: 4
Unterminated %{ block. Use %} to terminate.
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2021a</a><br></p></div><!--
##### SOURCE BEGIN #####
function impactorTempMeltFunc(fn,eta_0,E_a)
    %{
    Function to evolve impact melt chambers on Europa. Simulations end
    when there is a negligible amount of melt left from the impact. The
    ouputs are saved at the breakpoint in line 294. This model is meant for
    short term simulations, on the order of the sinking of impact melts.
    
    Variables:
        fn (string): is the directory to find the initial conditions (the
        outputs from the impact simulation)
        eta_0 (int): basal viscosity of ice in Pa s, 1e14 is a common value
        E_a (int): visocisty activation energy in Arrhenihus relationship
        given in J/mol, 50e3 is a common value

    Author: Evan Carnahan, evan.carnahan@utexas.edu, 11/20/2022
    %}publish('script.m','pdf')

    set(groot,'defaulttextinterpreter','latex')
    set(groot,'defaultAxesTickLabelInterpreter','latex')
    set(groot,'defaultLegendInterpreter','latex')
    warning off; % matrix is close to singular due to viscosity contrast
    %% Load initial condition to be evolved
    % make ice shell thickness based on impact code passed
    if any([all(fn == '03321') all(fn == '03800') all(fn == '04304')])
        d = 10*1e3; % m
    elseif any([all(fn == '03314') all(fn == '03402') all(fn == '03400')])
        d = 20*1e3; % m
    elseif any([all(fn == '03313') all(fn == '03701')])
        d = 30*1e3; % m
    elseif all(fn == '03330')
        d = 40*1e3; % m
    end

    % threshold of intial fluid left in ice shell to stop simulation at
    termFrac = 0.005;
    
    % load simulations from initial conditions folder
    fp = '../initial_conditions/ic';
    load([fp fn '_100.mat'],'T','phi');

    %% Set physical parameters and make dimensionless scales
    % physical parameters for ice
    T_t = 100; % surface temperature
    a = 185; % ice specific heat parameter
    b = 7.037; % ice specific heat parameter
    T_b = 273; % melting temperature, K
    rho_i = 920; % ice density at melting temperature, kg/m^3
    grav = 1.315; % Europa gravity, m/s^2 
    DT = T_b - T_t; % difference in temperature
    alpha = 1.6e-4; % thermal expansion coefficient, 1/K
    R = 8.314; % universal gas constant, J K^-1 mol^-1
    Apar = E_a/R/T_b; % viscosity exponenet

    % physical properties of water
    latHeat = 334e3; % latent heat of fusion, J/kg
    rho_w = 1e3; % density of water, kg/m^3
    c_pw = 4.186e3; % specific ehat of water, J/kg
    kappa_w = 0.56; %thermal diffusivity of water, W/(m K)
    porViscPar = 45;
    
    % temperature and melt fraction dependent viscosity, Pa s
    barrViscPhi = @(nonT,phi) max(exp(Apar*(T_b./(DT.*nonT+T_t)-1)).*exp(-porViscPar*phi),1e-2);
    c_fun = @(nonT) a+b*(DT*nonT+T_t); %J/(kg K)
    kappa_b = 3.3; %thermal conductivity of ice, set to be consistent with Cox and Bauer, 2015
    D_T = kappa_b/(rho_i *c_fun(1)); % thermal diffusicvity of ice, m^2/s
    c_pi = c_fun(1); %constant specific heat, J/(kg K)
    
    
    % thershold for melting: dimensionless boundary between partial and
    % fully melted regions
    mixZone = (rho_w*latHeat)/(rho_i*c_pi*DT);

    phi_fun = @(nonH) nonH * (rho_i*c_pi*DT)/(rho_w*latHeat); 
    TWater_fun = @(nonH) nonH * (rho_i*c_pi)/(rho_w*c_pw) - latHeat/(DT*c_pw) + 1;
    compBouy_fun = @(phi)  phi*rho_i*(rho_w/rho_i-1)*(grav*d^3/(eta_0*D_T));
    
    % conversion in dimensionless units with constant specific heat
    nonH_fun = @(nonT) nonT - 1; 
    nonT_fun = @(nonH) nonH + 1;
    % condictivity is weighted average of mixture components
    porKappaPrime_fun = @(phi,nonT) (phi*kappa_w + (1-phi).*kappa_b)/kappa_b;
    porNonH_fun = @(phi,nonT) (1-phi).*(nonH_fun(nonT)) + ...
        (phi*rho_w)./(rho_i*c_pi*DT).*(latHeat+c_pw*DT*(nonT-1));
    
    % characteristic scales for general convection
    t_c = d^2/D_T; % dimensionless time, s
    Ra = rho_i*grav*alpha*d^3*DT/(eta_0*D_T); % basal Rayleigh number
    
    % non-dimensionalize tmeprature
    T = (T - T_t)/DT;

    % thermal condutvity in convective ocean, set to maintain vertical
    % geotherm in ocean
    kappa_c = 100;

    %% build cylindirical grid for numerical solution
    % build grid
    grRes = 100; % grid resolution
    ocTh = grRes/5; % make ocean below the ice shell
    Gridp.xmin = 0; Gridp.xmax = 2; Gridp.Nx = grRes; 
    Gridp.ymin = -ocTh/grRes; Gridp.ymax = 1; Gridp.Ny = grRes+ocTh;
    Gridp.geom = 'cylindrical_rz';
    Grid = build_stokes_grid_cyl(Gridp);
    
    % convert inital condition to grid
    TGr = reshape(T,grRes,Grid.p.Nx);
    phiGr = reshape(phi,grRes,Grid.p.Nx);
    % get initial melt volumes
    phiOrig = sum(sum(phiGr(10:end,:),1).*Grid.p.V(Grid.p.dof_ymin)' * d^3);
    
    % build ocean layer
    TOc = ones(ocTh,Grid.p.Nx);
    phiOc = ones(ocTh,Grid.p.Nx);
    
    % combine ice shell and ocean
    TGr = [TOc; TGr];
    phiGr = [phiOc; phiGr];
    T = TGr(:);
    phi = phiGr(:);
    H = porNonH_fun(phi,T);
  
    %% build operators
    Zp = zeros(Grid.p.N);
    Ip = speye(Grid.p.N);
    [D,Edot,Dp,Gp,I,Gyy]=build_stokes_ops_cyl(Grid);
    linInds = find(Gyy > 0);
    [row,~] = ind2sub(size(Gyy),linInds);
    [X,Y] = meshgrid(Grid.p.xc,Grid.p.yc);
    
    %% Build boundary conditions for temperature and flow equation
    % Fix temperature at top of ice shell with Dirchlet BC
    T0 = 0;
    H0 = nonH_fun(T0);
    Param = struct('H',{},'g',{},'dof_dir',{});
    Param(1).H = struct('dof_dir',{},'dof_f_dir',{},'g',{},'dof_neu',{},'dof_f_neu',{},'qb',{},'dof_out',{});
    
    % fix bottom heat flux, Neumann BC, to maintain linear geotherm in ice shell
    qPrime = 1;
    Param.H(1).dof_dir = [Grid.p.dof_ymax];
    Param.H(1).dof_f_dir = [Grid.p.dof_f_ymax];
    Param.H(1).g = [H0*ones(length(Grid.p.dof_ymax),1)];
    
    Param.H(1).dof_neu = [Grid.p.dof_xmin;Grid.p.dof_xmax;Grid.p.dof_ymin];
    Param.H(1).dof_f_neu = [Grid.p.dof_f_xmin;Grid.p.dof_f_xmax;Grid.p.dof_f_ymin];
    Param.H(1).qb = [0*Grid.p.dof_f_xmin;0*Grid.p.dof_f_xmax;qPrime*ones(size(Grid.p.dof_f_ymin))];
    [BH,NH,fn_H] = build_bnd(Param.H,Grid.p,Ip);
    Param.H(1).dof_out = [Grid.p.dof_ymin];
    
    
    % Free slip boundary condition for Stokes equation
    Param(1).dof_dir =  [...
                      Grid.x.dof_xmax;...           %set x_max x-vel
                      Grid.x.dof_xmin;...           %set x_min x-vel
                      Grid.x.N+Grid.y.dof_ymin;...  %set y_min y-vel
                      Grid.x.N+Grid.y.dof_ymax;...  %set y_max y-vel
                      Grid.p.Nf+1];                 %set pressure
    Param(1).g = 0*Param.dof_dir;
    Param.g(end) = 0;
    B = I([Param.dof_dir],:);
    N = I;
    N(:,[Param.dof_dir]) = [];
    fs_T = nan(size(T));
    
    
    % create aarrays for time evolution storage
    it = 1e9;
    netMelt = [];
    phiDrain1 = 0;
    phiDrain2 = 0;
    tTot = 0;
    tVec = [];
    phiDrain1Vec = []; 
    phiDrain2Vec = [];
    phiFracRem = [];

    %% temporal evolution
    for i = 1:it
        
        % calculate porosity from enthalpy
        [T,phi] = enthMelt(H,mixZone,nonT_fun,phi_fun,TWater_fun);
        H = porNonH_fun(phi,T);
        
        %% Bouyancy force as the body force to Stokes flow
        %temp bouyancy
        Tplot= reshape(T,Grid.p.Ny,Grid.p.Nx);
        Tdiag = comp_mean(Tplot,1,1,Grid.p);
        Tvec = diag(Tdiag);
        Ty = Tvec(Grid.p.Nfx+1:Grid.p.Nf);
        fs_T(Ty>1) = -Ra*1;
        fs_T(Ty<=1) = -Ra*Ty(Ty<=1);
        
        %compositional bouyancy
        phiPlot= reshape(phi,Grid.p.Ny,Grid.p.Nx);
        phiDiag = diag(comp_mean(phiPlot,1,1,Grid.p));
        phiY = phiDiag(Grid.p.Nfx+1:Grid.p.Nf);
        fs_por = compBouy_fun(phiY);
        
        % higher porosity acts against Ra bouyancy force 
        fsVec = fs_T + fs_por;
        fs = [zeros(Grid.p.Nfx,1); fsVec; zeros(Grid.p.N,1)];
        
        %Gxx variable viscosity matrix
        nxxVec = zeros(Grid.x.Nfx,1);
        nxxVec(Grid.x.Ny+Grid.p.dof) = Tplot;
        
        %Gyy variable viscosity matrix
        nyyVec = zeros(Grid.y.Nfy,1);
        nyyVec(row) = Tplot;
        ncVec = comp_mean_corners(Tplot,-1,Grid.p);
        tempVec = [nxxVec;nyyVec;ncVec];
        
        %% Porosity and temperature dependent viscosity
        % porosity dependent viscosity
        phiPlot = reshape(phi,Grid.p.Ny,Grid.p.Nx);
        nxxVecPhi = zeros(Grid.x.Nfx,1);
        nxxVecPhi(Grid.x.Ny+Grid.p.dof) = phiPlot;
        
        %Gyy variable viscosity matrix
        nyyVecPhi = zeros(Grid.y.Nfy,1);
        nyyVecPhi(row) = phiPlot;
        
        ncVecPhi = comp_mean_corners(phiPlot,-1,Grid.p);
        phiVec = [nxxVecPhi;nyyVecPhi;ncVecPhi];
        
        % merge temperature and melt fraction viscosities
        viscVec = barrViscPhase(tempVec,phiVec,barrViscPhi);
        viscVec(isnan(viscVec)) = 0;
        viscMat = spdiags(viscVec,0,length(viscVec),length(viscVec));
        
        %% Stokes Flow calcualtion
        % make linear operators
        tau = D*2*viscMat*Edot;
        L = [tau,Gp;
            Dp,Zp];
        % solve for flow velocities
        u = solve_lbvp(L,fs,B,Param.g,N);
        vx = u(1:Grid.p.Nfx);
        vy = u(Grid.p.Nfx+1:(Grid.p.Nfx+Grid.p.Nfy));
        vm = [vx;vy];
        vmax= max(abs(vm));
        % Adaptive time stepping based on CFL condition
        dt = min([0.5*Grid.p.dx^2/kappa_c, Grid.p.dx/vmax,0.5*Grid.p.dy^2/kappa_c, Grid.p.dy/vmax])*0.8;
        p  = u((Grid.p.Nfx+Grid.p.Nfy+1):end);
        
        %% non-linear thermal conducitivity matricies
        kappaPrime = porKappaPrime_fun(phi,T);
        % select near bouundary ocean cells
        ocLog = Y(:) < 2/grRes & phi > 0.5;
        kappaPrime(ocLog) = kappa_c;
        kappaPrimePlot = reshape(kappaPrime,Grid.p.Ny,Grid.p.Nx);
        kappaFace = comp_mean(kappaPrimePlot,1,1,Grid.p);
                
        %% Advection of enthalpy, diffusion of temperature
        AH = build_adv_op(vm,H,dt,Gp,Grid.p,Param.H,'mc');
        L_T_I = Ip; 
        L_T_E_T = - dt*(-Dp*kappaFace*Gp);
        L_T_E_H = Ip - dt*(Dp*AH);
        RHS_T = L_T_E_H*H + L_T_E_T*T + (fn_H)*dt;
        H = solve_lbvp(L_T_I,RHS_T,BH,Param.H.g,NH);  
    
        %% calculate net melt and melt transported to "ocean"
        % make two planes to measure the melt transported through
        % plane 1
        abInd = 5;
        phiGr = reshape(phi,Grid.p.Ny,Grid.p.Nx);
        bdPhi = mean(phiGr(ocTh+abInd:ocTh+abInd+1,:),1).*Grid.p.V(Grid.p.dof_ymin)';
        vyGr = reshape(vy,Grid.y.Ny,Grid.y.Nx);
        bdVy = vyGr(ocTh+abInd+1,:);
        meltTrans = bdPhi .* bdVy / Grid.p.dy * dt * d^3;
        phiDrain2 = phiDrain2 - sum(meltTrans(bdVy < 0)); % m^3
        phiDrain2Vec = [phiDrain2Vec phiDrain2];
        
        % plane 2
        phiGr = reshape(phi,Grid.p.Ny,Grid.p.Nx);
        bdPhi = mean(phiGr(ocTh+(abInd-1):ocTh+(abInd-1)+1,:),1).*Grid.p.V(Grid.p.dof_ymin)';
        vyGr = reshape(vy,Grid.y.Ny,Grid.y.Nx);
        bdVy = vyGr(ocTh+(abInd-1)+1,:);
        meltTrans = bdPhi .* bdVy / Grid.p.dy * dt * d^3;
        phiDrain1 = phiDrain1 - sum(meltTrans(bdVy < 0)); % m^3
        phiDrain1Vec = [phiDrain1Vec phiDrain1];
        
        % total melt left
        netMelt = [netMelt sum(phi .* Grid.p.V * d^3)];
        % select near bouundary ocean cells
        % time stepping
        tTot = tTot + dt*t_c/(3.154e7); %Yrs
        tVec = [tVec tTot];
    
        % calculate remaining phi above near ocean, bottom 20% of ice shell
        phiRem = sum(sum(phiGr(ocTh+grRes/5:end,:),1).*Grid.p.V(Grid.p.dof_ymin)' * d^3);
        phiFracRem = [phiFracRem phiRem/phiOrig];

        % condition for ending simulation
        if phiFracRem(end) < termFrac || (i > 1000 && phiFracRem(end) > phiFracRem(end-1))
            % save point
            save(['impact_' fn '_eta0_' num2str(log10(eta_0)) '_Ea_' num2str(E_a/1e3) '_output.mat'],...
                'Tplot','phi','Grid','phiDrain1Vec','phiDrain2Vec','phiOrig','tVec',...
                'phiFracRem','T','phi','tVec','phiDrain1Vec','phiDrain2Vec','phiOrig')
            break
        end
        
    
        %% PLOTTING
         if mod(i,10) == 0
             i
    
            figure(4);
            [PSI,psi_min,psi_max] = comp_streamfun(vm,Grid.p);
            set(gcf, 'Position', [50 50 1500 600])
            subplot(3,3,1)
            cla;
            hold on
            axis equal
            contourf(X*d/1e3,Y*d/1e3-Grid.p.dy,Tplot*DT+T_t,40,'linestyle','none'),view(2),hold on
            c = colorbar('NorthOutside');
            caxis([min(Tplot(:)) max(Tplot(:))]*DT+T_t);
            cStrVal = linspace(min(PSI(:)),max(PSI(:)),10);
            contour(Grid.p.xf*d/1e3,Grid.p.yf*d/1e3,PSI,'k','LevelList',cStrVal);
            c.Label.String = 'Temperature, K';
            xlabel('x-dir, km')
            ylabel('z-dir, km')
            
            subplot(3,3,2)
            cla;
            axis equal
            hold on
            contourf(X,Y,reshape(phi,Grid.p.Ny,Grid.p.Nx),40,'linestyle','none'),view(2),hold on
            c = colorbar('NorthOutside');
            contour(X,Y,reshape(phi,Grid.p.Ny,Grid.p.Nx),'r','LevelList',5e-2)
            xlabel('x-dir, 1')
            ylabel('z-dir, 1')
            c.Label.String = 'Melt fraction, 1';
            
                
            subplot(3,3,3)
            cla;
            plot(mean(reshape(phi,Grid.p.Ny,Grid.p.Nx),2),Grid.p.yc)
            ylabel('z-dir, 1');
            xlabel('Average melt fraction');
            
            subplot(3,3,4)
            cla;
            plot(mean(reshape(T,Grid.p.Ny,Grid.p.Nx),2),Grid.p.yc)
            xlabel('Avg. temp');
            ylabel('z-dir, 1');
            
            
            subplot(3,3,5)
            cla;
            hold on
            plot(phiFracRem);
            ylabel('Total melt remaining, \%');
            xlabel('Time, yrs')
            
            subplot(3,3,6)
            cla;
            hold on
            axis equal
            contourf(X,Y,reshape(kappaPrimePlot,Grid.p.Ny,Grid.p.Nx),40,'linestyle','none'),view(2),hold on
            c = colorbar('NorthOutside');
            xlabel('x-dir, m')
            ylabel('z-dir, m')
            c.Label.Interpreter = 'latex';
            c.TickLabelInterpreter = 'latex';
            c.Label.String = 'Non-dim thermal conductivity';
            
            [Xc,Yf] = meshgrid(Grid.p.xc,Grid.p.yf);
            subplot(3,3,7)
            cla;
            plot(tVec,phiDrain1Vec);
            hold on
            plot(tVec,phiDrain2Vec);
            legend('intefrace','1 above interface','Location','NorthWest');
            ylabel('Melt drained, m$^3$');
            xlabel('Time, yrs')
            
            subplot(3,3,8)
            cla;
            plot(tVec,phiDrain1Vec/phiOrig*100);
            hold on
            plot(tVec,phiDrain2Vec/phiOrig*100);
            legend('interface','1 above interface','Location','NorthWest');
            ylabel('Percentage of melt drained, \%');
            xlabel('Time, yrs')
            
            subplot(3,3,9)
            cla;
            axis equal
            contourf(Xc,Yf,reshape(-fsVec,Grid.p.Ny+1,Grid.p.Nx),40,'linestyle','none'),view(2),hold on
            c = colorbar('NorthOutside');
            c.Label.Interpreter = 'latex';
            c.TickLabelInterpreter = 'latex';
            c.Label.String = 'Total Bouyancy, 1';
            xlabel('x-dir, 1')
            ylabel('z-dir, 1')
            
         end
    end
end
##### SOURCE END #####
--></body></html>